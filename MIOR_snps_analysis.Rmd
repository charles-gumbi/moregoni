---
title: 'Microtus oregoni Autosomal vs Sex chromosome genetic structure'
author: "charles-gumbi"
date: '`r Sys.Date()`'
output:
  pdf_document: default
  html_document: default
email: chrlesgumbi@gmail.com
---

# SNP Analysis Workflow for *Microtus oregoni*
This document contains the analysis of SNP data comparing autosomal vs. sex chromosome genetic structure.  
Each section is annotated for clarity, and we also describe what to expect from the outputs.
---

# Clear enviroment

```{r clear_the_enviroment, echo=FALSE}
rm(list=ls())
```

# ------------------------------------------------------------------------------
# Load SNP dataset and metadata, and filter for biallelic SNPs
# ------------------------------------------------------------------------------

# Load the VCF file containing SNP data
# - convertNA = TRUE: convert missing genotype calls to NA
# - skip = 0: start reading from the first line
# - checkFile = TRUE: verify the file exists
# - check_keys = TRUE: check for duplicate keys in the VCF header

```{r import_vcf, echo=FALSE}
# Load required library
library(vcfR)          # For reading and manipulating VCF files
library(tidyverse)     # For data manipulation
library(stringr)       # For string operations

# ------------------------------------------------------------------------------
# Step 1: Load the VCF file
# ------------------------------------------------------------------------------
nohapvcf <- read.vcfR(
  "~/radseq/nohaps/population/populations.snps.vcf",
  convertNA = TRUE,
  skip = 0,
  checkFile = TRUE,
  check_keys = TRUE
)

# ------------------------------------------------------------------------------
# Step 2: Filter for biallelic SNPs
# ------------------------------------------------------------------------------

# Extract the fixed (INFO) fields from the VCF
fix_fields <- nohapvcf@fix

# Biallelic SNPs have only one alternate allele (i.e., no commas in ALT field)
biallelic_mask <- !str_detect(fix_fields[, "ALT"], ",")

# Subset the VCF object to retain only biallelic SNPs
nohapvcf <- nohapvcf[biallelic_mask, ]

# ------------------------------------------------------------------------------
# Step 3: Load metadata
# ------------------------------------------------------------------------------

# Read metadata containing sample information (e.g., location, sex, state)
metadata <- read.csv(
  "~/radseq/moregoni/data/mior_metadata_20250420.csv",
  header = TRUE
)
```

*Output:* You should see the number of SNPs, individuals, and some metadata about your dataset. This confirms the file was read correctly.

# ------------------------------------------------------------------------------
# Convert VCF to genind object and summarize sample sizes by population
# ------------------------------------------------------------------------------
```{r, vcf_to_geind }
# Load required libraries
library(vcfR)         # For reading and handling VCF files
library(adegenet)     # For population genetics analysis and genind objects
library(tibble)       # For data frame manipulation
library(parallel)     # For detecting available CPU cores
library(doParallel)   # For registering parallel backend
library(foreach)      # For parallel loops
library(dplyr)        # For data manipulation
library(ggplot2)      # For plotting
library(hrbrthemes)   # For clean ggplot themes

# ------------------------------------------------------------------------------
# Step 1: Set up parallel processing
# ------------------------------------------------------------------------------

set.seed(101)  # Set seed for reproducibility
num_cores <- detectCores() - 1  # Detect number of cores, leave one free
cl <- makeCluster(num_cores)   # Create cluster
registerDoParallel(cl)         # Register parallel backend

# ------------------------------------------------------------------------------
# Step 2: Convert VCF to genind object
# ------------------------------------------------------------------------------

# Convert VCF object (already loaded as `nohapvcf`) to genind format
# This format is used for population genetics analyses in adegenet
nohapgenind <- vcfR2genind(nohapvcf)

# ------------------------------------------------------------------------------
# Step 3: Convert genind to data frame and merge metadata
# ------------------------------------------------------------------------------

# Convert genind object to a data frame (genotypes only)
nohapgenind_df <- genind2df(nohapgenind, usepop = FALSE)

# Add sample IDs as a column
nohapgenind_df <- rownames_to_column(nohapgenind_df, "sample.id")

# Merge genotype data with metadata (e.g., location, sex, lat/long)
nohapgenind_df <- merge(nohapgenind_df, metadata, by = "sample.id")

# ------------------------------------------------------------------------------
# Step 4: Extract metadata and create coordinates
# ------------------------------------------------------------------------------

# Extract non-genotype columns (metadata)
other_data <- subset(nohapgenind_df[, -(2:117010)])  # Adjust column range as needed

# Create coordinate data frame for spatial analysis (if needed)
coord <- data.frame(x = other_data$lat, y = other_data$long)

# ------------------------------------------------------------------------------
# Step 5: Convert data frame back to genind in parallel (optional)
# ------------------------------------------------------------------------------

# Split data into chunks for parallel processing
chunk_size <- ceiling(nrow(nohapgenind_df) / num_cores)
chunks <- split(nohapgenind_df, ceiling(seq_along(1:nrow(nohapgenind_df)) / chunk_size))

# Convert each chunk to genind object in parallel
genind_chunks <- foreach(chunk = chunks, .packages = "adegenet") %dopar% {
  adegenet::df2genind(
    X = chunk[, c(2:117010)],  # Genotype columns
    sep = "",                  # No separator in allele coding
    ncode = 1,                 # Number of characters per allele
    ind.names = chunk$sample.id,
    loc.names = NULL,
    pop = chunk$location,
    NA.char = "NA",
    ploidy = 2,
    type = "codom",            # Codominant markers
    strata = subset(chunk[, -(2:117010)]),  # Metadata
    hierarchy = NULL
  )
}

# Note: Combining genind objects is non-trivial and may require manual merging

# ------------------------------------------------------------------------------
# Step 6: Stop parallel cluster
# ------------------------------------------------------------------------------

stopCluster(cl)  # Clean up parallel resources

# ------------------------------------------------------------------------------
# Step 7: Check population structure
# ------------------------------------------------------------------------------

# View population assignments from original genind object
pop(nohapgenind)

# ------------------------------------------------------------------------------
# Step 8: Summarize sample sizes by population
# ------------------------------------------------------------------------------

# Count number of samples per location
location_counts <- nohapgenind_df %>%
  group_by(location) %>%
  count(name = "count")

# ------------------------------------------------------------------------------
# Step 9: Plot sample size distribution
# ------------------------------------------------------------------------------

ggplot(location_counts, aes(x = location, y = count)) +
  geom_bar(stat = "identity", fill = "skyblue", color = "black") +
  labs(
    title = "Distribution of Sample Counts by Location",
    x = "Location",
    y = "Count"
  ) +
  theme_ipsum()
```

# ------------------------------------------------------------------------------
# Population Structure Analysis using ADMIXTURE Output
# ------------------------------------------------------------------------------
# This script processes and visualizes population structure data generated by 
# the ADMIXTURE software. It performs the following steps:
#
# 1. Loads a list of sample identifiers from a text file.
# 2. Iteratively reads ADMIXTURE Q-matrix output files for K values ranging from 1 to 10.
#    - Each Q-matrix contains ancestry proportions for each individual across K clusters.
#    - The data is reshaped from wide to long format for easier plotting.
# 3. Combines all K-level data into a single tibble and merges it with sample metadata.
#    - Metadata must include sample IDs and location information.
# 4. Generates bar plots for selected K values (K=2, K=3, K=4) showing individual ancestry proportions.
#    - Individuals are grouped by location using faceted plots.
#    - Aesthetic enhancements are applied using custom themes and color scales.
# 5. Optionally combines the K=2, K=3, and K=4 plots into a single vertical layout.
# 6. Saves each plot as a high-resolution PNG file for publication or presentation.
#
# Required R packages: tidyverse, hrbrthemes, ggthemes, forcats, patchwork
# ------------------------------------------------------------------------------

```{r pop_structure, echo=FALSE}
# Load required libraries
library(tidyverse)    # Includes readr, dplyr, ggplot2, tidyr, etc.
library(hrbrthemes)   # For theme_ipsum() used in ggplot
library(ggthemes)     # For scale_fill_gdocs()
library(forcats)      # For fct_inorder() used in facet_grid
library(patchwork)    # For combining plots with plot_layout

# Load sample list from file
samplelist <- read_tsv("~/radseq/admixture/file.list", 
                       col_names = "sample.id")

# Initialize an empty tibble to store all data
all_data <- tibble(sample.id = character(),
                   k = numeric(),
                   Q = character(),
                   value = numeric())

# Loop through K values from 1 to 10
for (k in 1:10) {
  # Read Q file for current K value
  data <- read_delim(paste0("~/radseq/admixture/file.", k, ".Q"),
                     col_names = paste0("Q", seq(1:k)),
                     delim = " ")
  
  # Add sample IDs and K value to the data
  data$sample.id <- samplelist$sample.id
  data$k <- k
  
  # Convert data from wide to long format
  data <- data %>% 
    gather(Q, value, -sample.id, -k)
  
  # Append to all_data
  all_data <- rbind(all_data, data)
}

# Merge with metadata (assumes 'metadata' is already loaded in your environment)
all_data <- merge(all_data, metadata, by = "sample.id")

# Create plots for K = 2, 3, and 4
# K 1
k1plot <- all_data %>%
  filter(k == 1) %>%
  ggplot(aes(factor(sample.id), value, fill = factor(Q))) +
  geom_col(color = "gray", size = 0.1) +
  facet_grid(~fct_inorder(location), switch = "x", scales = "free", space = "free") +
  theme_ipsum() + 
  labs(x = "Individuals", title = "K=1", y = "Ancestry") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(panel.spacing.x = unit(0.1, "lines"),
        axis.text.x = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_gdocs(guide = FALSE)
# K2 
k2plot <- all_data %>%
  filter(k == 2) %>%
  ggplot(aes(factor(sample.id), value, fill = factor(Q))) +
  geom_col(color = "gray", size = 0.1) +
  facet_grid(~fct_inorder(location), switch = "x", scales = "free", space = "free") +
  theme_ipsum() + 
  labs(x = "Individuals", title = "K=2", y = "Ancestry") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(panel.spacing.x = unit(0.1, "lines"),
        axis.text.x = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_gdocs(guide = FALSE)
# K3
k3plot <- all_data %>%
  filter(k == 3) %>%
  ggplot(aes(factor(sample.id), value, fill = factor(Q))) +
  geom_col(color = "gray", size = 0.1) +
  facet_grid(~fct_inorder(location), switch = "x", scales = "free", space = "free") +
  theme_ipsum() + 
  labs(x = "Individuals", title = "K=3", y = "Ancestry") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(panel.spacing.x = unit(0.1, "lines"),
        axis.text.x = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_gdocs(guide = FALSE)
# K4 
k4plot <- all_data %>%
  filter(k == 4) %>%
  ggplot(aes(factor(sample.id), value, fill = factor(Q))) +
  geom_col(color = "gray", size = 0.1) +
  facet_grid(~fct_inorder(location), switch = "x", scales = "free", space = "free") +
  theme_ipsum() + 
  labs(x = "Individuals", title = "K=4", y = "Ancestry") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(panel.spacing.x = unit(0.1, "lines"),
        axis.text.x = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_gdocs(guide = FALSE)


# K5 
k5plot <- all_data %>%
  filter(k == 5) %>%
  ggplot(aes(factor(sample.id), value, fill = factor(Q))) +
  geom_col(color = "gray", size = 0.1) +
  facet_grid(~fct_inorder(location), switch = "x", scales = "free", space = "free") +
  theme_ipsum() + 
  labs(x = "Individuals", title = "K=5", y = "Ancestry") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(panel.spacing.x = unit(0.1, "lines"),
        axis.text.x = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_gdocs(guide = FALSE)

# K6
k6plot <- all_data %>%
  filter(k == 6) %>%
  ggplot(aes(factor(sample.id), value, fill = factor(Q))) +
  geom_col(color = "gray", size = 0.1) +
  facet_grid(~fct_inorder(location), switch = "x", scales = "free", space = "free") +
  theme_ipsum() + 
  labs(x = "Individuals", title = "K=5", y = "Ancestry") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(panel.spacing.x = unit(0.1, "lines"),
        axis.text.x = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_gdocs(guide = FALSE)

#  Optional:Combine plots vertically
#combined_k <- k2plot + k3plot + k4plot + plot_layout(ncol = 1)

# Save individual plots
ggsave(plot = k1plot, filename = "~/radseq/moregoni/out_plots/K1_plot.png", width = 8, height = 6, dpi = 300)
ggsave(plot = k2plot, filename = "~/radseq/moregoni/out_plots/K2_plot.png", width = 8, height = 6, dpi = 300)
ggsave(plot = k3plot, filename = "~/radseq/moregoni/out_plots/K3_plot.png", width = 8, height = 6, dpi = 300)
ggsave(plot = k4plot, filename = "~/radseq/moregoni/out_plots/K4_plot.png", width = 8, height = 6, dpi = 300)
ggsave(plot = k5plot, filename = "~/radseq/moregoni/out_plots/K5_plot.png", width = 8, height = 6, dpi = 300)
ggsave(plot = k6plot, filename = "~/radseq/moregoni/out_plots/K6_plot.png", width = 8, height = 6, dpi = 300)


# Optional: Save combined plot
# ggsave(plot = combined_k, filename = "~/radseq/moregoni/out_plots/combined_k_plot.png", width = 6, height = 8, dpi = 300)

```


Principal Component Analysis with SNPRelate

```{r pca_analysis, echo=FALSE}
library(SNPRelate)
library(tidyverse)
snpgdsVCF2GDS("~/radseq/nohaps/population/populations.snps.vcf",
              "~/radseq/nohaps/population/nohap_population.filtered.gds", method="biallelic.only")

# loading gds object 
genofile <- openfn.gds("~/radseq/nohaps/population/nohap_population.filtered.gds", readonly = F)
```

adding data to gds object 

```{r gds, echo=FALSE}
add.gdsn(genofile, "pop.group", metadata$location)
add.gdsn(genofile, "sex", metadata$sex)
add.gdsn(genofile, "state", metadata$state)
```

pruning linked loci

```{r prunning_loci, }
snpset_pruned <- snpgdsLDpruning(genofile, autosome.only = F)
names(snpset_pruned)

# Making a list of sites 
snpset.id <- unlist(snpset_pruned)
# getting  all selected snp id
snpset.id <- unlist(unname(snpset_pruned))
head(snpset.id)
```


# ------------------------------------------------------------------------------
# Principal Component Analysis (PCA) using SNPRelate and ggplot2
# ------------------------------------------------------------------------------
```{r pca_with_genlight, echo=FALSE}
# Load required libraries
library(SNPRelate)     # For working with GDS files and performing PCA
library(tidyverse)     # For data manipulation and visualization
library(cowplot)       # For clean ggplot themes
library(forcats)       # For handling categorical variables in plots

# ------------------------------------------------------------------------------
# Step 1: Convert VCF to GDS format
# ------------------------------------------------------------------------------

# Convert a VCF file containing SNP data to GDS format
# This step filters for biallelic SNPs only, which are required for SNPRelate
snpgdsVCF2GDS("~/radseq/nohaps/population/populations.snps.vcf",
              "~/radseq/nohaps/population/nohap_population.filtered.gds",
             method = "biallelic.only")

# ------------------------------------------------------------------------------
# Step 2: Load the GDS file
# ------------------------------------------------------------------------------

# Open the GDS file for reading and writing
# This object will be used for all downstream SNPRelate functions
genofile <- openfn.gds("~/radseq/nohaps/population/nohap_population.filtered.gds", readonly = FALSE)

# ------------------------------------------------------------------------------
# Step 3: Add metadata to the GDS object
# ------------------------------------------------------------------------------

# Add sample metadata to the GDS file
# These variables will be useful for grouping and plotting PCA results
add.gdsn(genofile, "pop.group", metadata$location)  # Add population group
add.gdsn(genofile, "sex", metadata$sex)             # Add sex information
add.gdsn(genofile, "state", metadata$state)         # Add state or region

# ------------------------------------------------------------------------------
# Step 4: Prune linked loci (LD pruning)
# ------------------------------------------------------------------------------

# Perform linkage disequilibrium (LD) pruning to remove correlated SNPs
# This helps reduce redundancy and improves PCA performance
snpset_pruned <- snpgdsLDpruning(genofile, autosome.only = FALSE)

# View the names of the pruned SNP sets (usually grouped by chromosome)
names(snpset_pruned)

# Flatten the list of pruned SNPs into a single vector of SNP IDs
snpset.id <- unlist(unname(snpset_pruned))

# Preview the first few SNP IDs selected for PCA
head(snpset.id)

# ------------------------------------------------------------------------------
# Step 5: Perform Principal Component Analysis (PCA)
# ------------------------------------------------------------------------------

# Run PCA on the pruned SNP set
# - num.thread: number of threads for parallel computation
# - eigen.cnt: number of principal components to compute
# - missing.rate: maximum allowed missing genotype rate
# - maf: minimum minor allele frequency threshold
pca <- snpgdsPCA(
  genofile,
  num.thread = 2,
  eigen.cnt = 16,
  snp.id = snpset.id,
  missing.rate = 0.10,
  maf = 0.05,
  autosome.only = FALSE
)

# View PCA summary output
pca

# Calculate the percentage of variance explained by each principal component
pc.percent <- pca$varprop * 100
round(pc.percent, 2)  # Round to two decimal places

# ------------------------------------------------------------------------------
# Step 6: Prepare PCA results for plotting
# ------------------------------------------------------------------------------

# Create a data frame with sample IDs and the first two principal components
tab <- data.frame(
  sample.id = pca$sample.id,
  PC1 = pca$eigenvect[, 1],
  PC2 = pca$eigenvect[, 2],
  stringsAsFactors = FALSE
)

# Merge PCA results with sample metadata
# This allows us to color and shape points by population and sex
tab <- merge(tab, metadata, by = "sample.id")

# ------------------------------------------------------------------------------
# Step 7: Visualize PCA results using ggplot2
# ------------------------------------------------------------------------------

# Define a custom color palette for populations
q_palette <- c("#440154", "#0072B2", "#D55E00")

# Create PCA scatter plot
pca_plot <- tab %>%
  ggplot(aes(x = PC1, y = PC2)) +
  geom_hline(yintercept = 0) +  # Add horizontal reference line
  geom_vline(xintercept = 0) +  # Add vertical reference line
  geom_point(aes(colour = location, shape = sex), size = 3, show.legend = TRUE) +
  scale_colour_manual(values = q_palette) +  # Apply custom colors
  xlim(-0.3, 0.3) +  # Set x-axis limits
  ylim(-0.3, 0.3) +  # Set y-axis limits
  labs(
    x = "Principal Component 1 (19.5%)",
    y = "Principal Component 2 (9.7%)",
    shape = "Sex",
    colour = "Population"
  ) +
  theme_cowplot() +  # Apply clean theme
  theme(
    axis.text.y = element_text(colour = "black", size = 12),
    axis.text.x = element_text(colour = "black", size = 12),
    axis.title = element_text(colour = "black", size = 12),
    panel.border = element_rect(colour = "black", fill = NA, size = 1),
    panel.background = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 15),
    text = element_text(size = 12, family = "sans")
  )

# ------------------------------------------------------------------------------
# Step 8: Save PCA plot to file
# ------------------------------------------------------------------------------

# Export the PCA plot as a high-resolution PNG image
ggsave(
  plot = pca_plot,
  filename = "~/radseq/moregoni/out_plots/pca_plot.png",
  width = 6, height = 8, dpi = 300
)

# ------------------------------------------------------------------------------
## - A PCA plot showing genetic structure among individuals
# - Individuals are grouped by population and sex
# - Useful for identifying population clusters or sex-linked differentiation
# ------------------------------------------------------------------------------

```


