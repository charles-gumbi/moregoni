---
title: 'Microtus oregoni Autosomal vs Sex chromosome genetic structure'
author: "charles-gumbi"
date: '`r Sys.Date()`'
output:
  pdf_document: default
  html_document: default
email: chrlesgumbi@gmail.com
---

# SNP Analysis Workflow for *Microtus oregoni*
This document contains the analysis of SNP data comparing autosomal vs. sex chromosome genetic structure.  
Each section is annotated for clarity, and we also describe what to expect from the outputs.

---

# 1. Install Required Packages
We first ensure that all required packages are installed.  
Some packages are from CRAN, others from GitHub.


```{r install packages}
# Installing from GitHub requires installing devtools
install.packages("devtools")
#packages("devtools")
devtools::install_github("SexGenomicsToolkit/sgtr")
devtools::install_github("TheWangLab/algatr")
install.packages("parallelly", dependencies = T)

# Install the r2vcftools library from GitHub
devtools::install_github("Bioconductor-mirror/LEA", force=T)
devtools::install_github("nspope/r2vcftools", force=T)


remotes::install_github("nspope/r2vcftools")
if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install("gdsfmt")
BiocManager::install("SNPRelate")
```

---

# 2. Load Libraries
Load the R libraries that will be used throughout the workflow.

```{r loading libraries}
#library(sgtr)
library(stringr)
library(adegenet)
library(data.table)
library(vcfR)
library(RColorBrewer)
library(reshape)
library(hierfstat)
library(tidyverse)
library(pcadapt)
library(tibble)
library(here)
library(pinfsc50)
library(utils)
library(fields)
library(admisc)
library(vegan)
library(lfmm)
#library(spdep)
#library(LEA)
library(wordcloud)
library(ggmap)
library(maps)
library(mapdata)
library(stringr)
library(sp)
#library(sf)
library(algatr)
library(here)
library(viridis)
library(tidyr)
library(gridExtra)
library(tibble)
library(SNPRelate)
#library(SeqArray)
library(wingen)
library(purrr)
library(cowplot)
library(vcfR)
library(dplyr)
library(gdsfmt)
library(SNPRelate)
library(tidyverse)
library(tidyverse)
library(readr)
library(ggplot2)
library(forcats)
library(ggthemes)
library(patchwork)
library(devtools)
```

*Output:* No plots. You should see the libraries load without error. If there are errors, it usually means a package is missing.

# Clear enviroment
```{r clear_the_enviroment, echo=FALSE}
rm(list=ls())
```

---
# Import and Inspect VCF Data
We import VCF data, inspect its structure, and prepare it for downstream analysis.
```{r import_vcf, echo=FALSE}
#SNPs dataset
nohapvcf <- read.vcfR("~/radseq/nohaps/population/populations.snps.vcf", convertNA = TRUE, skip = 0, checkFile = T, check_keys = T)
#metadata dataset
metadata <- read.csv ("~/radseq/moregoni/data/mior_metadata_20250420.csv", header = T)
```

*Output:* You should see the number of SNPs, individuals, and some metadata about your dataset. This confirms the file was read correctly.

# Convert VCF to Geind Object
The `genind` format is useful for population genetics analyses in adegenet.
```{r genind, echo=FALSE}
# Load required libraries
library(vcfR)
library(adegenet)
library(tibble)
library(parallel)
library(doParallel)
library(foreach)

# Set seed for reproducibility
set.seed(101)

# Detect number of cores and register parallel backend
num_cores <- detectCores() - 1  # leave one core free
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# Convert VCF to genind object (this part is not easily parallelizable, but we keep it)
nohapgenind <- vcfR2genind(nohapvcf)

# Convert genind to data frame in parallel
nohapgenind_df <- genind2df(nohapgenind, usepop = FALSE)
nohapgenind_df <- rownames_to_column(nohapgenind_df, "sample.id")

# Merge metadata (can be parallelized if metadata is large)
nohapgenind_df <- merge(nohapgenind_df, metadata, by = "sample.id")

# Extract metadata columns
other_data <- subset(nohapgenind_df[, -(2:117010)])

# Create coordinates
coord <- data.frame(x = other_data$lat, y = other_data$long)

# Parallelize df2genind conversion (this is tricky, so we split the data and recombine)
# Split data into chunks
chunk_size <- ceiling(nrow(nohapgenind_df) / num_cores)
chunks <- split(nohapgenind_df, ceiling(seq_along(1:nrow(nohapgenind_df)) / chunk_size))

# Process chunks in parallel
genind_chunks <- foreach(chunk = chunks, .packages = "adegenet") %dopar% {
  adegenet::df2genind(
    X = chunk[, c(2:117010)],
    sep = "",
    ncode = 1,
    ind.names = chunk$sample.id,
    loc.names = NULL,
    pop = chunk$location,
    NA.char = "NA",
    ploidy = 2,
    type = "codom",
    strata = subset(chunk[, -(2:117010)]),
    hierarchy = NULL
  )
}

# Combine genind objects (if needed, depending on downstream analysis)
# You may need to use `genind2df` again and merge manually if combining is not straightforward

# Stop cluster
stopCluster(cl)

# Check population structure
pop(nohapgenind)

```

# Samples size summary population
```{r sample_size, echo=FALSE}
 # Load required libraries
library(dplyr)
library(ggplot2)
library(hrbrthemes)

# Group and count samples by location
location_counts <- nohapgenind_df %>%
  group_by(location) %>%
  count(name = "count")

# Create violin plot
ggplot(location_counts, aes(y = count)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Distribution of Sample Counts by Location",
       x = "Location",
       y = "Count") +
  theme_ipsum()

```


# ------------------------------------------------------------------------------
# Population Structure Analysis using ADMIXTURE Output
# ------------------------------------------------------------------------------
# This script processes and visualizes population structure data generated by 
# the ADMIXTURE software. It performs the following steps:
#
# 1. Loads a list of sample identifiers from a text file.
# 2. Iteratively reads ADMIXTURE Q-matrix output files for K values ranging from 1 to 10.
#    - Each Q-matrix contains ancestry proportions for each individual across K clusters.
#    - The data is reshaped from wide to long format for easier plotting.
# 3. Combines all K-level data into a single tibble and merges it with sample metadata.
#    - Metadata must include sample IDs and location information.
# 4. Generates bar plots for selected K values (K=2, K=3, K=4) showing individual ancestry proportions.
#    - Individuals are grouped by location using faceted plots.
#    - Aesthetic enhancements are applied using custom themes and color scales.
# 5. Optionally combines the K=2, K=3, and K=4 plots into a single vertical layout.
# 6. Saves each plot as a high-resolution PNG file for publication or presentation.
#
# Required R packages: tidyverse, hrbrthemes, ggthemes, forcats, patchwork
# ------------------------------------------------------------------------------

```{r pop_structure, echo=FALSE}
# Load required libraries
library(tidyverse)    # Includes readr, dplyr, ggplot2, tidyr, etc.
library(hrbrthemes)   # For theme_ipsum() used in ggplot
library(ggthemes)     # For scale_fill_gdocs()
library(forcats)      # For fct_inorder() used in facet_grid
library(patchwork)    # For combining plots with plot_layout

# Load sample list from file
samplelist <- read_tsv("~/radseq/admixture/file.list", 
                       col_names = "sample.id")

# Initialize an empty tibble to store all data
all_data <- tibble(sample.id = character(),
                   k = numeric(),
                   Q = character(),
                   value = numeric())

# Loop through K values from 1 to 10
for (k in 1:10) {
  # Read Q file for current K value
  data <- read_delim(paste0("~/radseq/admixture/file.", k, ".Q"),
                     col_names = paste0("Q", seq(1:k)),
                     delim = " ")
  
  # Add sample IDs and K value to the data
  data$sample.id <- samplelist$sample.id
  data$k <- k
  
  # Convert data from wide to long format
  data <- data %>% 
    gather(Q, value, -sample.id, -k)
  
  # Append to all_data
  all_data <- rbind(all_data, data)
}

# Merge with metadata (assumes 'metadata' is already loaded in your environment)
all_data <- merge(all_data, metadata, by = "sample.id")

# Create plots for K = 2, 3, and 4
# K 1
k1plot <- all_data %>%
  filter(k == 1) %>%
  ggplot(aes(factor(sample.id), value, fill = factor(Q))) +
  geom_col(color = "gray", size = 0.1) +
  facet_grid(~fct_inorder(location), switch = "x", scales = "free", space = "free") +
  theme_ipsum() + 
  labs(x = "Individuals", title = "K=1", y = "Ancestry") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(panel.spacing.x = unit(0.1, "lines"),
        axis.text.x = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_gdocs(guide = FALSE)
# K2 
k2plot <- all_data %>%
  filter(k == 2) %>%
  ggplot(aes(factor(sample.id), value, fill = factor(Q))) +
  geom_col(color = "gray", size = 0.1) +
  facet_grid(~fct_inorder(location), switch = "x", scales = "free", space = "free") +
  theme_ipsum() + 
  labs(x = "Individuals", title = "K=2", y = "Ancestry") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(panel.spacing.x = unit(0.1, "lines"),
        axis.text.x = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_gdocs(guide = FALSE)
# K3
k3plot <- all_data %>%
  filter(k == 3) %>%
  ggplot(aes(factor(sample.id), value, fill = factor(Q))) +
  geom_col(color = "gray", size = 0.1) +
  facet_grid(~fct_inorder(location), switch = "x", scales = "free", space = "free") +
  theme_ipsum() + 
  labs(x = "Individuals", title = "K=3", y = "Ancestry") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(panel.spacing.x = unit(0.1, "lines"),
        axis.text.x = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_gdocs(guide = FALSE)
# K4 
k4plot <- all_data %>%
  filter(k == 4) %>%
  ggplot(aes(factor(sample.id), value, fill = factor(Q))) +
  geom_col(color = "gray", size = 0.1) +
  facet_grid(~fct_inorder(location), switch = "x", scales = "free", space = "free") +
  theme_ipsum() + 
  labs(x = "Individuals", title = "K=4", y = "Ancestry") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(panel.spacing.x = unit(0.1, "lines"),
        axis.text.x = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_gdocs(guide = FALSE)


# K5 
k5plot <- all_data %>%
  filter(k == 5) %>%
  ggplot(aes(factor(sample.id), value, fill = factor(Q))) +
  geom_col(color = "gray", size = 0.1) +
  facet_grid(~fct_inorder(location), switch = "x", scales = "free", space = "free") +
  theme_ipsum() + 
  labs(x = "Individuals", title = "K=5", y = "Ancestry") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(panel.spacing.x = unit(0.1, "lines"),
        axis.text.x = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_gdocs(guide = FALSE)

# K6
k6plot <- all_data %>%
  filter(k == 6) %>%
  ggplot(aes(factor(sample.id), value, fill = factor(Q))) +
  geom_col(color = "gray", size = 0.1) +
  facet_grid(~fct_inorder(location), switch = "x", scales = "free", space = "free") +
  theme_ipsum() + 
  labs(x = "Individuals", title = "K=5", y = "Ancestry") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(panel.spacing.x = unit(0.1, "lines"),
        axis.text.x = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_gdocs(guide = FALSE)

#  Optional:Combine plots vertically
#combined_k <- k2plot + k3plot + k4plot + plot_layout(ncol = 1)

# Save individual plots
ggsave(plot = k1plot, filename = "~/radseq/moregoni/out_plots/K1_plot.png", width = 8, height = 6, dpi = 300)
ggsave(plot = k2plot, filename = "~/radseq/moregoni/out_plots/K2_plot.png", width = 8, height = 6, dpi = 300)
ggsave(plot = k3plot, filename = "~/radseq/moregoni/out_plots/K3_plot.png", width = 8, height = 6, dpi = 300)
ggsave(plot = k4plot, filename = "~/radseq/moregoni/out_plots/K4_plot.png", width = 8, height = 6, dpi = 300)
ggsave(plot = k5plot, filename = "~/radseq/moregoni/out_plots/K5_plot.png", width = 8, height = 6, dpi = 300)
ggsave(plot = k6plot, filename = "~/radseq/moregoni/out_plots/K6_plot.png", width = 8, height = 6, dpi = 300)


# Optional: Save combined plot
# ggsave(plot = combined_k, filename = "~/radseq/moregoni/out_plots/combined_k_plot.png", width = 6, height = 8, dpi = 300)

```


Principal Component Analysis with SNPRelate

```{r pca_analysis, echo=FALSE}
library(SNPRelate)
library(tidyverse)
snpgdsVCF2GDS("~/radseq/nohaps/population/populations.snps.vcf",
              "~/radseq/nohaps/population/nohap_population.filtered.gds", method="biallelic.only")

# loading gds object 
genofile <- openfn.gds("~/radseq/nohaps/population/nohap_population.filtered.gds", readonly = F)
```

adding data to gds object 

```{r gds, echo=FALSE}
add.gdsn(genofile, "pop.group", metadata$location)
add.gdsn(genofile, "sex", metadata$sex)
add.gdsn(genofile, "state", metadata$state)
```

pruning linked loci

```{r prunning_loci, }
snpset_pruned <- snpgdsLDpruning(genofile, autosome.only = F)
names(snpset_pruned)

# Making a list of sites 
snpset.id <- unlist(snpset_pruned)
# getting  all selected snp id
snpset.id <- unlist(unname(snpset_pruned))
head(snpset.id)
```


# ------------------------------------------------------------------------------
# Principal Component Analysis (PCA) using SNPRelate and ggplot2
# ------------------------------------------------------------------------------
```{r pca_with_genlight, echo=FALSE}
# Load required libraries
library(SNPRelate)     # For working with GDS files and performing PCA
library(tidyverse)     # For data manipulation and visualization
library(cowplot)       # For clean ggplot themes
library(forcats)       # For handling categorical variables in plots

# ------------------------------------------------------------------------------
# Step 1: Convert VCF to GDS format
# ------------------------------------------------------------------------------

# Convert a VCF file containing SNP data to GDS format
# This step filters for biallelic SNPs only, which are required for SNPRelate
snpgdsVCF2GDS("~/radseq/nohaps/population/populations.snps.vcf",
              "~/radseq/nohaps/population/nohap_population.filtered.gds",
             method = "biallelic.only")

# ------------------------------------------------------------------------------
# Step 2: Load the GDS file
# ------------------------------------------------------------------------------

# Open the GDS file for reading and writing
# This object will be used for all downstream SNPRelate functions
genofile <- openfn.gds("~/radseq/nohaps/population/nohap_population.filtered.gds", readonly = FALSE)

# ------------------------------------------------------------------------------
# Step 3: Add metadata to the GDS object
# ------------------------------------------------------------------------------

# Add sample metadata to the GDS file
# These variables will be useful for grouping and plotting PCA results
add.gdsn(genofile, "pop.group", metadata$location)  # Add population group
add.gdsn(genofile, "sex", metadata$sex)             # Add sex information
add.gdsn(genofile, "state", metadata$state)         # Add state or region

# ------------------------------------------------------------------------------
# Step 4: Prune linked loci (LD pruning)
# ------------------------------------------------------------------------------

# Perform linkage disequilibrium (LD) pruning to remove correlated SNPs
# This helps reduce redundancy and improves PCA performance
snpset_pruned <- snpgdsLDpruning(genofile, autosome.only = FALSE)

# View the names of the pruned SNP sets (usually grouped by chromosome)
names(snpset_pruned)

# Flatten the list of pruned SNPs into a single vector of SNP IDs
snpset.id <- unlist(unname(snpset_pruned))

# Preview the first few SNP IDs selected for PCA
head(snpset.id)

# ------------------------------------------------------------------------------
# Step 5: Perform Principal Component Analysis (PCA)
# ------------------------------------------------------------------------------

# Run PCA on the pruned SNP set
# - num.thread: number of threads for parallel computation
# - eigen.cnt: number of principal components to compute
# - missing.rate: maximum allowed missing genotype rate
# - maf: minimum minor allele frequency threshold
pca <- snpgdsPCA(
  genofile,
  num.thread = 2,
  eigen.cnt = 16,
  snp.id = snpset.id,
  missing.rate = 0.10,
  maf = 0.05,
  autosome.only = FALSE
)

# View PCA summary output
pca

# Calculate the percentage of variance explained by each principal component
pc.percent <- pca$varprop * 100
round(pc.percent, 2)  # Round to two decimal places

# ------------------------------------------------------------------------------
# Step 6: Prepare PCA results for plotting
# ------------------------------------------------------------------------------

# Create a data frame with sample IDs and the first two principal components
tab <- data.frame(
  sample.id = pca$sample.id,
  PC1 = pca$eigenvect[, 1],
  PC2 = pca$eigenvect[, 2],
  stringsAsFactors = FALSE
)

# Merge PCA results with sample metadata
# This allows us to color and shape points by population and sex
tab <- merge(tab, metadata, by = "sample.id")

# ------------------------------------------------------------------------------
# Step 7: Visualize PCA results using ggplot2
# ------------------------------------------------------------------------------

# Define a custom color palette for populations
q_palette <- c("#440154", "#0072B2", "#D55E00")

# Create PCA scatter plot
pca_plot <- tab %>%
  ggplot(aes(x = PC1, y = PC2)) +
  geom_hline(yintercept = 0) +  # Add horizontal reference line
  geom_vline(xintercept = 0) +  # Add vertical reference line
  geom_point(aes(colour = location, shape = sex), size = 3, show.legend = TRUE) +
  scale_colour_manual(values = q_palette) +  # Apply custom colors
  xlim(-0.3, 0.3) +  # Set x-axis limits
  ylim(-0.3, 0.3) +  # Set y-axis limits
  labs(
    x = "Principal Component 1 (19.5%)",
    y = "Principal Component 2 (9.7%)",
    shape = "Sex",
    colour = "Population"
  ) +
  theme_cowplot() +  # Apply clean theme
  theme(
    axis.text.y = element_text(colour = "black", size = 12),
    axis.text.x = element_text(colour = "black", size = 12),
    axis.title = element_text(colour = "black", size = 12),
    panel.border = element_rect(colour = "black", fill = NA, size = 1),
    panel.background = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 15),
    text = element_text(size = 12, family = "sans")
  )

# ------------------------------------------------------------------------------
# Step 8: Save PCA plot to file
# ------------------------------------------------------------------------------

# Export the PCA plot as a high-resolution PNG image
ggsave(
  plot = pca_plot,
  filename = "~/radseq/moregoni/out_plots/pca_plot.png",
  width = 6, height = 8, dpi = 300
)

# ------------------------------------------------------------------------------
## - A PCA plot showing genetic structure among individuals
# - Individuals are grouped by population and sex
# - Useful for identifying population clusters or sex-linked differentiation
# ------------------------------------------------------------------------------

```


